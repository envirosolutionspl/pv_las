# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PhotovoltaicsLPDialog
                                 A QGIS plugin
 Wyznaczanie lokalizacji pod farmy fotowoltaiczne LP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-09-04
        git sha              : $Format:%H$
        copyright            : (C) 2025 by EnviroSolutions Sp. z o. o.
        email                : office@envirosolutions.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import tempfile
import zipfile
from pathlib import Path

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtGui import QColor, QFont
from qgis.utils import iface
from qgis.core import (
    Qgis, QgsRasterLayer, QgsProject, QgsVectorLayer, QgsLineSymbol,
    QgsFillSymbol, QgsSingleSymbolRenderer, QgsMapSettings, QgsRectangle,
    QgsApplication, QgsWkbTypes, QgsCoordinateReferenceSystem,
    QgsVectorFileWriter, QgsPrintLayout, QgsLayoutItemMap, QgsLayoutPoint,
    QgsUnitTypes, QgsLayoutSize, QgsLayoutItemPicture, QgsLayoutItemLabel,
    QgsLayoutItemLegend, QgsLayerTree, QgsLayoutItemScaleBar,
    QgsScaleBarSettings, QgsLayoutExporter
) 

from .modules.dane_bdot_task import PobierzBdotTask
from .modules.analiza_task import AnalizaTask

from .modules.zapisz_xlsx import ZapiszXLSX
from .modules.generuj_raport import GenerujRaport
from .utils import (
    openFile, pushMessageBox, pushMessageBoxCritical, 
    pushMessage, pushLogInfo
)
from .constants import (
    WMTS_URL_TEMPLATE, MAPA_BAZOWA_LAYERS, CRS_EPSG_2180, MAPA_BAZOWA_URL,
    MAPA_BAZOWA_LAYER_NAME, FILENAME_POWIATY, FILENAME_WYDZIELENIA,
    FILENAME_DROGI_LESNE, FILENAME_ODDZIALY, FILENAME_WYDZIELENIA_OPISY,
    FILENAME_NADLESNICTWO, LAYER_NAME_ODDZIALY, LAYER_NAME_POWIATY,
    LAYER_NAME_WYDZIELENIA, LAYER_NAME_DROGI_LESNE, LAYER_NAME_WYDZIELENIA_OPISY,
    LAYER_NAME_NADLESNICTWO, STYLE_COLOR_DROGI_LESNE, STYLE_WIDTH_DROGI_LESNE,
    STYLE_COLOR_WYDZIELENIA, STYLE_COLOR_WYDZIELENIA_OUTLINE, STYLE_WIDTH_WYDZIELENIA,
    RESULT_LAYER_OBSZARY, RESULT_LAYER_LINIE, RESULT_LAYER_DROGI, LAYOUT_CONFIG
)


# To wczytuje plik .ui, dzięki czemu PyQt uzupełni wtyczkę elementami z Qt Designera.
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'photovoltaics_LP_dialog_base.ui'))


class PhotovoltaicsLPDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Konstruktor."""
        super(PhotovoltaicsLPDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.iface = iface
        self.plugin_icon = ':/plugins/photovoltaics_LP/icons/fotowoltaika.svg'

        self.wydzielenia = None
        self.wydzielenia_opisy = None
        self.drogi_lesne = None
        self.powiaty = None
        self.obszary = None
        self.drogi = None
        self.linie= None
        self.linie_bdot10k = None
        self.oddzialy = None
        self.nadlesnictwo = None
        self.mapa_bazowa = None
        self.drogi_bdot10k = None
        self.drogi_list = []
        self.linie_list = []
        self.save_layer_path = ""

    


        self.pobierzWarstwyPochodneBtn.clicked.connect(self.pobierzWarstwyPochodne)
        self.wczytajBdot10kBtn.clicked.connect(self.wczytajDaneBdot10k)
        self.analizaBtn.clicked.connect(self.analizaData)
        self.raportBtn.clicked.connect(self.generujRaport)
        self.wydrukBtn.clicked.connect(self.generujWydruk)
        self.resetujBtn.clicked.connect(self.resetuj)
        self.zamknijBtn.clicked.connect(self.zamknij)
        self.zapisBtn.clicked.connect(self.zapiszWarstwy)
        self.helpBtn.clicked.connect(self.help)


    def dodajMapeBazowa(self):
        """
        dodaje mapę bazową
        """
   
        wmts_url = WMTS_URL_TEMPLATE.format(
            layers=MAPA_BAZOWA_LAYERS,
            crs=CRS_EPSG_2180,
            url=MAPA_BAZOWA_URL
        )
        
        self.mapa_bazowa = QgsRasterLayer(wmts_url, MAPA_BAZOWA_LAYER_NAME, 'wms')
        if self.mapa_bazowa.isValid():
            root = QgsProject.instance().layerTreeRoot()
            QgsProject.instance().addMapLayer(self.mapa_bazowa, False)
            root.insertLayer(len(root.children()), self.mapa_bazowa)
            self.mapa_bazowa.renderer().setOpacity(0.2)
            self.mapa_bazowa.triggerRepaint()

        else:
            pushMessageBoxCritical(self, "Nie udało się wczytać mapy bazowej", "Sprawdź połączenie z internetem!")

    def pobierzWarstwyPochodne(self):
        """Ładuje warstwy pochodne z folderu .zip do projektu).
        """
        dialog = QFileDialog()
        dialog.setFileMode(QFileDialog.DirectoryOnly)
        self.selected_data = dialog.getOpenFileName(
            None, "Wybierz archiwum", "", "Archiwum ZIP (*.zip)")

        if self.selected_data[0]:
            self.pobierzWarstwyPochodneBtn.setEnabled(False)
            zf = zipfile.ZipFile(self.selected_data[0])
            tempdir= tempfile.TemporaryDirectory()
            zf.extractall(tempdir.name)
            powiaty_path = tempdir.name + '\\'+ FILENAME_POWIATY
            wydzielenia_path = tempdir.name + '\\'+ FILENAME_WYDZIELENIA
            drogi_lesne_path = tempdir.name + '\\'+ FILENAME_DROGI_LESNE
            oddzialy_path = tempdir.name + '\\'+ FILENAME_ODDZIALY
            wydzielenia_opisy_path = tempdir.name + '\\'+ FILENAME_WYDZIELENIA_OPISY
            nadlesnictwo_path = tempdir.name + '\\'+ FILENAME_NADLESNICTWO

            self.oddzialy= QgsVectorLayer(oddzialy_path, LAYER_NAME_ODDZIALY, "ogr")
            self.powiaty = QgsVectorLayer(powiaty_path, LAYER_NAME_POWIATY, "ogr")
            self.wydzielenia = QgsVectorLayer(wydzielenia_path, LAYER_NAME_WYDZIELENIA, "ogr")
            self.drogi_lesne = QgsVectorLayer(drogi_lesne_path, LAYER_NAME_DROGI_LESNE, "ogr")
            self.wydzielenia_opisy = QgsVectorLayer( wydzielenia_opisy_path, LAYER_NAME_WYDZIELENIA_OPISY, "ogr")
            self.nadlesnictwo = QgsVectorLayer( nadlesnictwo_path, LAYER_NAME_NADLESNICTWO, "ogr")
            self.nadlesnictwo.dataProvider().setEncoding(u'windows-1250')
           
            
            if self.drogi_lesne.isValid() and self.wydzielenia.isValid():
                    # dodanie stylu do warstwy z drogami leśnymi
                    symbol =  QgsLineSymbol.createSimple(
                    {'color': STYLE_COLOR_DROGI_LESNE, 'outline_color' : STYLE_COLOR_DROGI_LESNE,  'outline_style': 'solid',
                    'outline_width': STYLE_WIDTH_DROGI_LESNE})
                    renderer = QgsSingleSymbolRenderer(symbol)
                    self.drogi_lesne.setRenderer(renderer)

                    # dodanie stylu do warstwy z wydzieleniami leśnymi
                    symbol =  QgsFillSymbol.createSimple(
                    {'color': STYLE_COLOR_WYDZIELENIA, 'outline_color' : STYLE_COLOR_WYDZIELENIA_OUTLINE,  'outline_style':'solid',
                    'outline_width': STYLE_WIDTH_WYDZIELENIA})
                    renderer = QgsSingleSymbolRenderer(symbol)
                    self.wydzielenia.setRenderer(renderer)


                    QgsProject.instance().addMapLayers( [self.drogi_lesne, self.wydzielenia])
                    self.dodajMapeBazowa() #dodawanie warstwy bazowej
                    ms = QgsMapSettings()
                    ms.setLayers([self.drogi_lesne, self.wydzielenia])  
                    rect = QgsRectangle(ms.fullExtent()) 
                    iface.mapCanvas().setExtent(rect) # ustawaianie do zakresu warstwy wydzielenni warstwy dróg leśnych
                    iface.mapCanvas().refresh()
                    pushMessageBox(self, "Ładowanie warstw pochodnych zakonczone sukcesem!")
                    self.pobierzWarstwyPochodneBtn.setEnabled(False)
                    self.wczytajBdot10kBtn.setEnabled(True)
                    self.resetujBtn.setEnabled(True)

                   
            else:
                pushMessageBoxCritical(self, "Nie udało się wczytać warstw pochodnych", "Sprawdź poprawność danych!")
                self.resetuj()    
                    
        else:
               
            pushMessageBoxCritical(self, "Nie wybrano danych", "Wybierz dane!")
            
            
    def wczytajDaneBdot10k(self):
        """
        Ściąga dane_bdot10k z internetu do projektu.
        """
       
        features = [obiect for obiect in self.powiaty.getFeatures()]
        pushMessage(self.iface, 'Pobieranie danych BDOT10k')
        task = PobierzBdotTask(
            description='Pobieranie danych',
            drogi_layer = self.drogi_bdot10k,
            linie_layer =self.linie_bdot10k,
            features = features, 
            drogi_list =self.drogi_list,
            linie_list = self.linie_list,
            iface= iface,
            wczytajBdot10kBtn = self.wczytajBdot10kBtn,
            analizaBtn = self.analizaBtn,
            resetujBtn = self.resetujBtn

        )
        QgsApplication.taskManager().addTask(task)
        pushLogInfo('runtask')
        
        
    def analizaData(self):
        """
        Wykonuje analizę na potrzeby farm fotowoltalicznych.
        """
        pushMessage(self.iface, 'Trwa analiza')
        task = AnalizaTask(
            description='Trwa analiza',
            wydzielenia_opisy = self.wydzielenia_opisy,
            wydzielenia =self.wydzielenia,
            oddzialy = self.oddzialy, 
            drogi_lesne =self.drogi_lesne,
            mapa_bazowa = self.mapa_bazowa,
            iface= iface,
            analizaBtn = self.analizaBtn,
            zapisBtn = self.zapisBtn,
            raportBtn=self.raportBtn,
            wydrukBtn=self.wydrukBtn,
            resetujBtn = self.resetujBtn

        )
        QgsApplication.taskManager().addTask(task)
        pushLogInfo('runtask')     

    def zapiszWarstwy(self):
        """
        Zapisuje warstwy wyznaczonych obszarów, najbliższych dróg i 
        najbiższych linii energetycznych do wybranej lokalizacji
        """
    
        self.save_layer_path = QFileDialog.getSaveFileName(
                None, "Wybierz lokalizację", 'wyznaczone_obszary', '*.shp')
        if len(self.save_layer_path[0]) > 0:
               
            try:
                wyznaczone_obszary = QgsProject.instance().mapLayersByName(RESULT_LAYER_OBSZARY)[0]
                features_obszary = [feature for feature in wyznaczone_obszary.getFeatures()]
                fields_obszary = wyznaczone_obszary.fields()
                path=self.save_layer_path[0]
                self.tworzWarstwy(path, QgsWkbTypes.Polygon, fields_obszary, 'Wyznaczone_obszary', features_obszary)

                linie = QgsProject.instance().mapLayersByName(RESULT_LAYER_LINIE)[0]
                features_linie = [feature for feature in linie.getFeatures()]
                fields_linie = linie.fields()
                path_linie = ('/').join(path.split('/')[:-1]) + '//'+ 'najblizsze_linie_energetyczne.shp'
                self.tworzWarstwy(path_linie, QgsWkbTypes.LineString, fields_linie, 'Najbliższe_linie_energetyczne', features_linie)

                drogi = QgsProject.instance().mapLayersByName(RESULT_LAYER_DROGI)[0]
                features_drogi = [feature for feature in drogi.getFeatures()]
                fields_drogi = drogi.fields()
                path_drogi = ('/').join(path.split('/')[:-1]) + '//'+ 'najblizsze_drogi.shp'
                self.tworzWarstwy(path_drogi, QgsWkbTypes.LineString, fields_drogi, 'Najbliższe_drogi', features_drogi)      

                pushMessageBox(self, "Zapisywanie warstw zakonczone sukcesem!")
                folder_name = ('/').join(path.split('/')[:-1])
                openFile(folder_name)
            except:
                pushMessageBoxCritical(self, "Spróbuj jeszcze raz", "Problem z zapisem warstw!")


    def tworzWarstwy(self,path, typ_geom, fields, name, features):
        """
        Tworzy warstwy wyznaczonych obszarów, najbliższych dróg i 
        najbiższych linii energetycznych.
        """

        crs = QgsCoordinateReferenceSystem(CRS_EPSG_2180)
        transform_context = QgsProject.instance().transformContext()
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        if Qgis.QGIS_VERSION_INT >= 31030:
            writer = QgsVectorFileWriter.create(
                path, fields, typ_geom, crs, transform_context, save_options)
        else:
            writer = QgsVectorFileWriter(
                self.save_layer_path[0], 'UTF-8', fields,  typ_geom, crs, "ESRI Shapefile")
        if writer.hasError() != QgsVectorFileWriter.NoError:
            pushMessageBoxCritical(self, "Spróbuj jeszcze raz", "Problem z zapisem warstwy!")
        else:
            del writer
            layer = QgsVectorLayer(
                path, name, 'ogr')

            prov = layer.dataProvider()
            prov.addFeatures(features)        

    def generujRaport(self):
        """
        Generuje raport i zapisuje go jako plik excela w 
        wybranej lokalizacji. W razie problemu pojawia się wiadomość.
        """
        try:
            nazwa_nadlesnictwa = [feature[3] for feature in self.nadlesnictwo.getFeatures()]

            self.linie = QgsProject.instance().mapLayersByName(RESULT_LAYER_LINIE)[0]

            self.drogi = QgsProject.instance().mapLayersByName(RESULT_LAYER_DROGI)[0]

            self.obszary = QgsProject.instance().mapLayersByName(RESULT_LAYER_OBSZARY)[0]


            nazwa_pliku = ZapiszXLSX().zapiszExcel()
          
            if nazwa_pliku:
                generuj_raport = GenerujRaport()
                generuj_raport.tworzTabele(nazwa_pliku, self.obszary, self.drogi, self.linie, nazwa_nadlesnictwa[0])
                pushMessageBox(self, "Generowanie raportu zakonczone sukcesem!")
                folder_name = ('/').join(nazwa_pliku.split('/')[:-1])
                openFile(folder_name)
        except:
            pushMessageBoxCritical(self, "Spróbuj jeszcze raz", "Problem z wygenerowaniem raportu!")

    def generujWydruk(self):
        """
        Generuje wydruk i zapisuje go jako plik w wybranej lokalizacji. 
        W razie problemu pojawia się wiadomość.
        """
        try:
            lc = LAYOUT_CONFIG
            nazwa_nadlesnictwa = [feature[3] for feature in self.nadlesnictwo.getFeatures()]
            self.linie = QgsProject.instance().mapLayersByName(RESULT_LAYER_LINIE)[0]
            self.drogi = QgsProject.instance().mapLayersByName(RESULT_LAYER_DROGI)[0]
            self.obszary = QgsProject.instance().mapLayersByName(RESULT_LAYER_OBSZARY)[0]
            warstwy=[self.obszary, self.drogi, self.linie]
            typy_obrazu = "jpg (*.jpg);;bitmap (*.bmp);;tiff (*.tiff);; pdf (*.pdf)"
            opcje = QFileDialog.Options()
            nazwa_pliku = QFileDialog.getSaveFileName(
                    None, "Zapisz jako ...", "", filter=typy_obrazu, options=opcje)
            
            project = QgsProject.instance()
            layout = QgsPrintLayout(project)
            layout.initializeDefaults()
            map = QgsLayoutItemMap(layout)
            
            # Map configuration
            rect_val = lc['MAP']['RECT']
            map.setRect(*rect_val)
            extent = QgsRectangle()
            nadlesnictwo_geom = next(self.nadlesnictwo.getFeatures(), None)
            if nadlesnictwo_geom:
                extent = nadlesnictwo_geom.geometry().boundingBox()
            extent.scale(lc['MAP']['EXTENT_SCALE']) 
            ms = QgsMapSettings()
            ms.setLayers(warstwy)  
            ms.setExtent(extent)
            map.setExtent(extent)
            map.setBackgroundColor(QColor(255,255,255))
            layout.addLayoutItem(map)
            map.attemptMove(QgsLayoutPoint(lc['MAP']['POS_X'], lc['MAP']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            map.attemptResize(QgsLayoutSize(
                lc['MAP']['SIZE_W'], lc['MAP']['SIZE_H'], QgsUnitTypes.LayoutMillimeters))
            
            # Logo LP
            logoLP = QgsLayoutItemPicture(layout)
            logoLP.setResizeMode(QgsLayoutItemPicture.Zoom)
            logoLP.setMode(QgsLayoutItemPicture.FormatRaster)
            logoLP.setPicturePath(lc['LOGO_LP']['PATH'])

            new_dim_lp = [
                lc['LOGO_LP']['ORIG_W'] * lc['LOGO_LP']['SCALE'], 
                lc['LOGO_LP']['ORIG_H'] * lc['LOGO_LP']['SCALE']
            ]
            logoLP.attemptMove(QgsLayoutPoint(lc['LOGO_LP']['POS_X'], lc['LOGO_LP']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            logoLP.attemptResize(QgsLayoutSize(*new_dim_lp, QgsUnitTypes.LayoutPixels))
            layout.addLayoutItem(logoLP)

            # Logo Enviro
            logoEnv = QgsLayoutItemPicture(layout)
            logoEnv.setResizeMode(QgsLayoutItemPicture.Zoom)
            logoEnv.setMode(QgsLayoutItemPicture.FormatRaster)
            logoEnv.setPicturePath(lc['LOGO_ENV']['PATH'])

            new_dim_env = [
                lc['LOGO_ENV']['ORIG_W'] * lc['LOGO_ENV']['SCALE'], 
                lc['LOGO_ENV']['ORIG_H'] * lc['LOGO_ENV']['SCALE']
            ]
            logoEnv.attemptMove(QgsLayoutPoint(lc['LOGO_ENV']['POS_X'], lc['LOGO_ENV']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            logoEnv.attemptResize(QgsLayoutSize(*new_dim_env, QgsUnitTypes.LayoutPixels))
            layout.addLayoutItem(logoEnv)

            # Arrow
            arrow = QgsLayoutItemPicture(layout)
            arrow.setResizeMode(QgsLayoutItemPicture.Zoom)
            arrow.setMode(QgsLayoutItemPicture.FormatRaster)
            arrow.setPicturePath(lc['ARROW']['PATH'])

            new_dim_arrow = [
                lc['ARROW']['ORIG_W'] * lc['ARROW']['SCALE'], 
                lc['ARROW']['ORIG_H'] * lc['ARROW']['SCALE']
            ]
            arrow.attemptMove(QgsLayoutPoint(lc['ARROW']['POS_X'], lc['ARROW']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            arrow.attemptResize(QgsLayoutSize(*new_dim_arrow, QgsUnitTypes.LayoutPixels))
            layout.addLayoutItem(arrow)
            
            # Title
            title = QgsLayoutItemLabel(layout)
            title.setText(lc['TITLE']['TEXT_TEMPLATE'].format(nazwa_nadlesnictwa))
            title.setFont(QFont('Arial', lc['TITLE']['FONT_SIZE']))
            title.adjustSizeToText()
            layout.addLayoutItem(title)
            title.attemptMove(QgsLayoutPoint(
                lc['TITLE']['POS_X'], lc['TITLE']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            title.attemptResize(QgsLayoutSize(lc['TITLE']['SIZE_W'], lc['TITLE']['SIZE_H']))
            title.setFrameEnabled(False)

            # Footer
            footer = QgsLayoutItemLabel(layout)
            footer.setText(lc['FOOTER']['TEXT'])
            footer.setFont(QFont('Arial', lc['FOOTER']['FONT_SIZE']))
            layout.addLayoutItem(footer)
            footer.attemptMove(QgsLayoutPoint(
                lc['FOOTER']['POS_X'], lc['FOOTER']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            footer.setFrameEnabled(False)

            # Legend
            legend = QgsLayoutItemLegend(layout)
            legend.setLinkedMap(map)
            layerTree = QgsLayerTree()

            for warstwa in warstwy:
                layerTree.addLayer(warstwa)

            legend.model().setRootGroup(layerTree)
            layout.addLayoutItem(legend)
            legend.attemptMove(QgsLayoutPoint(
                lc['LEGEND']['POS_X'], lc['LEGEND']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
            
            # ScaleBar
            scaleBar = QgsLayoutItemScaleBar(layout)
            scaleBar.setStyle('Single Box')
            scaleBar.setFont(QFont("Arial", 9))
            scaleBar.applyDefaultSize(QgsUnitTypes.DistanceMeters)
            scaleBar.setMapUnitsPerScaleBarUnit(1000.0)
            scaleBar.setSegmentSizeMode(QgsScaleBarSettings.SegmentSizeFitWidth)
            scaleBar.setMaximumBarWidth(lc['SCALEBAR']['MAX_WIDTH'])
            scaleBar.setNumberOfSegments(lc['SCALEBAR']['SEGMENTS'])
            scaleBar.setUnitsPerSegment(1*1000.0)
            scaleBar.setUnitLabel(lc['SCALEBAR']['UNIT_LABEL'])
            scaleBar.setLinkedMap(map)
            layout.addLayoutItem(scaleBar)
            scaleBar.attemptMove(QgsLayoutPoint(
                lc['SCALEBAR']['POS_X'], lc['SCALEBAR']['POS_Y'], QgsUnitTypes.LayoutMillimeters))
          
            if nazwa_pliku[0]:
                if  nazwa_pliku[0].endswith('.pdf'):

                    exporter = QgsLayoutExporter(layout)
                    exporter.exportToPdf(
                          nazwa_pliku[0],QgsLayoutExporter.PdfExportSettings())
                    
                    pushMessageBox(self, "Zapisywanie dokumentu zakończone sukcesem!")
                else:
                    exporter = QgsLayoutExporter(layout)
                    exporter.exportToImage(
                            nazwa_pliku[0], QgsLayoutExporter.ImageExportSettings())
                    pushMessageBox(self, "Zapisywanie obrazu zakończone sukcesem!")
                    
                
                folder_name = ('/').join(nazwa_pliku[0].split('/')[:-1])
                openFile(folder_name)
        except:
            pushMessageBoxCritical(self, "Spróbuj jeszcze raz", "Problem z zapisem dokumetu")

    def resetuj(self):
        """
        Resetuje dane
        """
        self.wydzielenia = None
        self.wydzielenia_opisy = None
        self.drogi_lesne = None
        self.powiaty = None
        self.obszary = None
        self.drogi = None
        self.linie= None
        self.linie_bdot10k = None
        self.oddzialy = None
        self.nadlesnictwo = None
        self.mapa_bazowa = None

        self.pobierzWarstwyPochodneBtn.setEnabled(True)
        self.wczytajBdot10kBtn.setEnabled(False)
        self.analizaBtn.setEnabled(False)
        self.zapisBtn.setEnabled(False)
        self.raportBtn.setEnabled(False)
        self.wydrukBtn.setEnabled(False)
        
    def zamknij(self):
        """
        Zamyka okno wtyczki
        """
        self.close()
    
    def help(self):
        """
        Otwiera instrukcję obsługi wtyczki w pdf
        """
        try:
            filepath = Path(__file__).parent / "Instrukcja.pdf"
            os.startfile(filepath)

        except:
            pushMessageBoxCritical(self, "Spróbuj jeszcze raz", "Problem z otwarciem pliku pdf")



